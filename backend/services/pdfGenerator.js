const PDFDocument = require('pdfkit');

class BrandAnalysisPDFGenerator {
  constructor() {
    this.doc = null;
    this.pageWidth = 612;
    this.pageHeight = 792;
    this.margin = 50;
    this.contentWidth = this.pageWidth - (this.margin * 2);
    
    // Updated color scheme to match website theme
    this.colors = {
      primary: '#7765e3',        // Main brand color
      primaryLight: '#a4abff',   // Lighter primary
      primaryDark: '#5e6ad2',    // Darker primary
      text: '#2d3142',           // Dark text
      textLight: '#4a4a6a',      // Light text
      textMuted: '#6b7280',      // Muted text
      background: '#ffffff',      // White background
      surface: '#f8f9ff',        // Light surface
      border: '#e4e7ff',         // Light border
      accent: '#10b981',         // Success green
      warning: '#f59e0b',        // Warning orange
      error: '#ef4444'           // Error red
    };
  }

  generateBrandAnalysisPDF(analysisData) {
    return new Promise((resolve, reject) => {
      try {
        this.doc = new PDFDocument({ 
          margin: this.margin,
          font: 'Helvetica'
        });
        const buffers = [];

        // Collect the PDF data
        this.doc.on('data', buffers.push.bind(buffers));
        this.doc.on('end', () => {
          const pdfData = Buffer.concat(buffers);
          resolve(pdfData);
        });

        // Generate the PDF content
        this.generateContent(analysisData);

        // Finalize the PDF
        this.doc.end();
      } catch (error) {
        console.error('❌ PDF Generation Error:', error);
        reject(new Error(`PDF generation failed: ${error.message}`));
      }
    });
  }

  generateContent(analysisData) {
    // Title Page
    this.addTitlePage(analysisData);
    this.doc.addPage();

    // Executive Summary
    this.addExecutiveSummary(analysisData);
    this.doc.addPage();

    // Share of Voice Analysis
    this.addShareOfVoiceSection(analysisData);
    this.doc.addPage();

    // Competitors Section
    this.addCompetitorsSection(analysisData);

    // Categories Analysis
    if (analysisData.categories && analysisData.categories.length > 0) {
      this.doc.addPage();
      this.addCategoriesSection(analysisData.categories, analysisData);
    }
  }

  addTitlePage(analysisData) {
    const centerX = this.pageWidth / 2;

    // Brand header bar with primary color
    this.doc
      .rect(0, 80, this.pageWidth, 6)
      .fill(this.colors.primary);

    // Main Title
    this.doc
      .fontSize(36)
      .fillColor(this.colors.text)
      .text('Brand Analysis Report', this.margin, 120, {
        align: 'center'
      });

    // Brand Name
    this.doc
      .fontSize(28)
      .fillColor(this.colors.primary)
      .text(analysisData.brandName || analysisData.domain, this.margin, 180, {
        align: 'center'
      });

    // Info Box with improved styling
    const boxY = 250;
    this.doc
      .rect(this.margin, boxY, this.contentWidth, 120)
      .stroke(this.colors.border)
      .fillAndStroke(this.colors.surface, this.colors.border);

    // Info content
    this.doc
      .fontSize(14)
      .fillColor(this.colors.textLight);

    const infoY = boxY + 25;
    this.addInfoRow('Domain:', analysisData.domain, infoY);
    this.addInfoRow('Analysis Date:', new Date(analysisData.analysisDate).toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }), infoY + 25);
    this.addInfoRow('Report Type:', 'Super User Analysis', infoY + 50);

    // Footer
    this.doc
      .fontSize(10)
      .fillColor(this.colors.textMuted)
      .text('Generated by Snowball - AI-Powered Brand Analysis', this.margin, 700, {
        align: 'center'
      });
  }

  addInfoRow(label, value, y) {
    this.doc
      .fontSize(12)
      .fillColor(this.colors.textLight);
    
    this.doc.text(label, this.margin + 20, y, { continued: true });
    this.doc.text(` ${value}`, { align: 'left' });
  }

  addExecutiveSummary(analysisData) {
    this.addSectionTitle('Executive Summary');

    // Metrics box with improved design
    const boxY = 140;
    this.doc
      .rect(this.margin, boxY, this.contentWidth, 150)
      .fillAndStroke(this.colors.surface, this.colors.border);

    // Key metrics
    const metricsY = boxY + 30;
    const col1X = this.margin + 30;
    const col2X = this.margin + (this.contentWidth / 2) + 30;

    this.addMetric('AI Visibility Score', `${Math.round(analysisData.aiVisibilityScore || 0)}%`, col1X, metricsY);
    this.addMetric('Brand Market Share', `${Math.round(analysisData.brandShare || 0)}%`, col2X, metricsY);
    this.addMetric('Total Mentions', (analysisData.totalMentions || 0).toString(), col1X, metricsY + 40);
    this.addMetric('Competitors Found', (analysisData.competitors?.length || 0).toString(), col2X, metricsY + 40);

    // Description
    this.doc
      .fontSize(16)
      .fillColor(this.colors.text)
      .text('Brand Description', this.margin, 320);

    this.doc
      .fontSize(12)
      .fillColor(this.colors.textLight)
      .text(analysisData.description || 'No description available.', this.margin, 350, {
        width: this.contentWidth,
        lineGap: 5
      });
  }

  addMetric(label, value, x, y) {
    this.doc
      .fontSize(10)
      .fillColor(this.colors.textMuted)
      .text(label, x, y);
    
    this.doc
      .fontSize(18)
      .fillColor(this.colors.primary)
      .text(value, x, y + 15);
  }

  addShareOfVoiceSection(analysisData) {
    this.addSectionTitle('Share of Voice Analysis');

    if (!analysisData.shareOfVoice || Object.keys(analysisData.shareOfVoice).length === 0) {
      this.doc
        .fontSize(12)
        .fillColor(this.colors.textMuted)
        .text('No Share of Voice data available.', this.margin, 140);
      return;
    }

    // Table header with primary color
    const tableY = 160;
    const rowHeight = 25;
    const col1X = this.margin;
    const col2X = this.margin + 200;
    const col3X = this.margin + 320;
    const col4X = this.margin + 420;

    // Header background
    this.doc
      .rect(col1X, tableY, this.contentWidth, rowHeight)
      .fill(this.colors.primary);

    // Header text
    this.doc
      .fontSize(12)
      .fillColor('white')
      .text('Brand/Competitor', col1X + 10, tableY + 8)
      .text('Share of Voice', col2X + 10, tableY + 8)
      .text('Mentions', col3X + 10, tableY + 8)
      .text('Rank', col4X + 10, tableY + 8);

    // Sort entries by percentage
    const sortedEntries = Object.entries(analysisData.shareOfVoice).sort((a, b) => b[1] - a[1]);
    
    let currentY = tableY + rowHeight;
    sortedEntries.forEach(([brand, percentage], index) => {
      const mentions = analysisData.mentionCounts[brand] || 0;
      const isEven = index % 2 === 0;
      
      // Row background
      if (isEven) {
        this.doc
          .rect(col1X, currentY, this.contentWidth, rowHeight)
          .fill(this.colors.surface);
      }

      // Row text
      this.doc
        .fontSize(11)
        .fillColor(this.colors.text)
        .text(brand.substring(0, 25), col1X + 10, currentY + 8)
        .text(`${percentage.toFixed(1)}%`, col2X + 10, currentY + 8)
        .text(mentions.toString(), col3X + 10, currentY + 8);

      // Rank indicator
      if (index === 0) {
        this.doc
          .fillColor(this.colors.warning)
          .text('★', col4X + 20, currentY + 8);
      } else {
        this.doc
          .fillColor(this.colors.textMuted)
          .text(`#${index + 1}`, col4X + 10, currentY + 8);
      }

      currentY += rowHeight;
    });
  }

  addCompetitorsSection(analysisData) {
    this.addSectionTitle('Competitor Analysis');

    if (!analysisData.competitors || analysisData.competitors.length === 0) {
      this.doc
        .fontSize(12)
        .fillColor(this.colors.textMuted)
        .text('No competitors identified in this analysis.', this.margin, 140);
      return;
    }

    this.doc
      .fontSize(14)
      .fillColor(this.colors.text)
      .text(`Found ${analysisData.competitors.length} competitors:`, this.margin, 140);

    let currentY = 170;
    analysisData.competitors.forEach((competitor, index) => {
      // Competitor box with improved styling
      this.doc
        .rect(this.margin, currentY, this.contentWidth, 30)
        .fillAndStroke(this.colors.surface, this.colors.border);

      // Competitor text
      this.doc
        .fontSize(12)
        .fillColor(this.colors.text)
        .text(`${index + 1}. ${competitor}`, this.margin + 15, currentY + 10);

      currentY += 35;
      
      // Add page break if needed
      if (currentY > 700 && index < analysisData.competitors.length - 1) {
        this.doc.addPage();
        currentY = 100;
      }
    });
  }

  addCategoriesSection(categories, analysisData = null) {
    this.addSectionTitle('Detailed Category Analysis');
    
    this.doc
      .fontSize(12)
      .fillColor(this.colors.textMuted)
      .text(`Analysis across ${categories.length} business categories with AI-generated insights:`, 
        this.margin, 140, { width: this.contentWidth });

    // Add competitor mention summary with improved design (if analysisData is available)
    let competitorMentionsY;
    if (analysisData) {
      competitorMentionsY = this.addCompetitorMentionSummary(analysisData);
    } else {
      // Skip competitor mention summary if no analysisData
      competitorMentionsY = 140;
    }

    let currentY = competitorMentionsY + 10; // Reduced spacing

    categories.forEach((category, index) => {
      // Category header with primary color
      this.doc
        .rect(this.margin, currentY, this.contentWidth, 25)
        .fill(this.colors.primary);

      this.doc
        .fontSize(14)
        .fillColor('white')
        .text(`Category ${index + 1}: ${category.categoryName}`, this.margin + 10, currentY + 8);

      currentY += 30; // Reduced spacing

      // Process prompts and responses
      if (category.prompts && category.prompts.length > 0) {
        category.prompts.forEach((prompt, promptIndex) => {
          // Calculate total content height needed for this prompt+response
          const promptText = prompt.promptText || 'No prompt text available';
          const promptHeight = this.doc.heightOfString(promptText, { width: this.contentWidth - 20 });
          
          let responseHeight = 0;
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            responseHeight = this.doc.heightOfString(prompt.aiResponse.responseText, { width: this.contentWidth - 20 });
          }
          
          const totalNeededHeight = 20 + promptHeight + 35 + responseHeight + 30; // Headers + content + spacing
          
          // Check if we need a new page - only if content won't fit
          if (currentY + totalNeededHeight > 730) {
            this.doc.addPage();
            currentY = 80;
          }

          // Prompt header with improved styling
          this.doc
            .rect(this.margin, currentY, this.contentWidth, 18)
            .fillAndStroke(this.colors.surface, this.colors.border);

          this.doc
            .fontSize(11)
            .fillColor(this.colors.text)
            .text(`Prompt ${promptIndex + 1}`, this.margin + 10, currentY + 5);

          currentY += 22;

          // Prompt text
          this.doc
            .fontSize(10)
            .fillColor(this.colors.textLight)
            .text(promptText, this.margin + 10, currentY, { 
              width: this.contentWidth - 20,
              lineGap: 1
            });

          currentY += promptHeight + 10;

          // AI Response
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            // Response header
            this.doc
              .rect(this.margin, currentY, this.contentWidth, 18)
              .fillAndStroke(this.colors.surface, this.colors.border);

            this.doc
              .fontSize(11)
              .fillColor(this.colors.text)
              .text('AI Response', this.margin + 10, currentY + 5);

            currentY += 22;

            // Response text
            const responseText = prompt.aiResponse.responseText;
            
            this.doc
              .fontSize(10)
              .fillColor(this.colors.text)
              .text(responseText, this.margin + 10, currentY, { 
                width: this.contentWidth - 20,
                lineGap: 1
              });

            currentY += responseHeight + 15;
          } else {
            this.doc
              .fontSize(10)
              .fillColor(this.colors.textMuted)
              .text('No AI response available.', this.margin + 10, currentY);
            currentY += 20;
          }
        });
      } else {
        this.doc
          .fontSize(11)
          .fillColor(this.colors.textMuted)
          .text('No prompts available for this category.', this.margin + 10, currentY);
        currentY += 25;
      }

      currentY += 10; // Reduced space between categories
    });
  }

  addCompetitorMentionSummary(analysisData) {
    // Use the actual mentionsByBrand data that was already extracted
    const mentionsByBrand = analysisData.mentionsByBrand || {};
    
    // Display mention summary organized by brand and prompts
    if (Object.keys(mentionsByBrand).length > 0) {
      this.doc
        .fontSize(16)
        .fillColor(this.colors.text)
        .text('Brand Mentions by Prompt', this.margin, 165);

      let summaryY = 190;
      
      // Sort brands by number of mentions (descending)
      const sortedBrands = Object.entries(mentionsByBrand)
        .sort(([,a], [,b]) => b.length - a.length);
      
      // Display each brand and its mentions organized by prompts
      sortedBrands.forEach(([brandName, mentions]) => {
        // Check if we need space for this brand section
        if (summaryY > 650) {
          this.doc.addPage();
          summaryY = 80;
        }

        // Brand header box
        this.doc
          .rect(this.margin, summaryY, this.contentWidth, 25)
          .fillAndStroke(this.colors.surface, this.colors.primary);

        this.doc
          .fontSize(14)
          .fillColor(this.colors.primary)
          .text(`${brandName.toUpperCase()} (${mentions.length} mentions)`, this.margin + 10, summaryY + 8);
        
        summaryY += 30;
        
        // Group mentions by unique prompts to avoid duplicates
        const promptGroups = {};
        mentions.forEach((mention) => {
          const promptText = mention.promptText || 'Unknown prompt';
          const key = promptText.substring(0, 100); // Use first 100 chars as key
          
          if (!promptGroups[key]) {
            promptGroups[key] = {
              promptText: promptText,
              categoryName: mention.categoryName || 'Unknown category',
              responses: []
            };
          }
          
          if (mention.responseText) {
            promptGroups[key].responses.push(mention.responseText);
          }
        });
        
        // Display each unique prompt and its details
        Object.values(promptGroups).forEach((group, index) => {
          // Check for page break
          if (summaryY > 680) {
            this.doc.addPage();
            summaryY = 80;
          }
          
          // Prompt header
          this.doc
            .fontSize(11)
            .fillColor(this.colors.text)
            .text(`${index + 1}. Category: ${group.categoryName}`, this.margin + 15, summaryY);
          
          summaryY += 15;
          
          // Prompt text (truncated)
          const promptPreview = group.promptText.length > 120 
            ? group.promptText.substring(0, 120) + '...'
            : group.promptText;
            
          this.doc
            .fontSize(10)
            .fillColor(this.colors.textLight)
            .text(`Prompt: "${promptPreview}"`, this.margin + 20, summaryY, {
              width: this.contentWidth - 40,
              lineGap: 1
            });
          
          summaryY += 25;
          
          // Response preview (first response if available)
          if (group.responses.length > 0) {
            const responsePreview = group.responses[0].length > 150 
              ? group.responses[0].substring(0, 150) + '...'
              : group.responses[0];
              
            this.doc
              .fontSize(9)
              .fillColor(this.colors.textMuted)
              .text(`Response: "${responsePreview}"`, this.margin + 20, summaryY, {
                width: this.contentWidth - 40,
                lineGap: 1
              });
              
            summaryY += 20;
          }
          
          summaryY += 8; // Space between prompts
        });
        
        summaryY += 15; // Space between brands
      });
      
      return summaryY + 15; // Return the Y position for continuing content
    } else {
      // No mentions found
      this.doc
        .fontSize(16)
        .fillColor(this.colors.text)
        .text('Brand Mentions by Prompt', this.margin, 165);
        
      this.doc
        .fontSize(12)
        .fillColor(this.colors.textMuted)
        .text('No brand mentions found in this analysis.', this.margin, 190);
      
      return 220; // Return default Y position if no mentions
    }
  }

  addSectionTitle(title) {
    // Section line with primary color
    this.doc
      .moveTo(this.margin, 110)
      .lineTo(this.pageWidth - this.margin, 110)
      .stroke(this.colors.primary);

    // Section title
    this.doc
      .fontSize(20)
      .fillColor(this.colors.text)
      .text(title, this.margin, 80);
  }
}

module.exports = BrandAnalysisPDFGenerator;