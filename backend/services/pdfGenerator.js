const PDFDocument = require('pdfkit');

class BrandAnalysisPDFGenerator {
  constructor() {
    this.doc = null;
    this.pageWidth = 612;
    this.pageHeight = 792;
    this.margin = 50;
    this.contentWidth = this.pageWidth - (this.margin * 2);
  }

  generateBrandAnalysisPDF(analysisData) {
    return new Promise((resolve, reject) => {
      try {
        this.doc = new PDFDocument({ margin: this.margin });
        const buffers = [];

        // Collect the PDF data
        this.doc.on('data', buffers.push.bind(buffers));
        this.doc.on('end', () => {
          const pdfData = Buffer.concat(buffers);
          resolve(pdfData);
        });

        // Generate the PDF content
        this.generateContent(analysisData);

        // Finalize the PDF
        this.doc.end();
      } catch (error) {
        console.error('❌ PDF Generation Error:', error);
        reject(new Error(`PDF generation failed: ${error.message}`));
      }
    });
  }

  generateContent(analysisData) {
    // Title Page
    this.addTitlePage(analysisData);
    this.doc.addPage();

    // Executive Summary
    this.addExecutiveSummary(analysisData);
    this.doc.addPage();

    // Share of Voice Analysis
    this.addShareOfVoiceSection(analysisData);
    this.doc.addPage();

    // Competitors Section
    this.addCompetitorsSection(analysisData);

    // Categories Analysis
    if (analysisData.categories && analysisData.categories.length > 0) {
      this.doc.addPage();
      this.addCategoriesSection(analysisData.categories);
    }
  }

  addTitlePage(analysisData) {
    const centerX = this.pageWidth / 2;

    // Brand header bar
    this.doc
      .rect(0, 80, this.pageWidth, 4)
      .fill('#6658f4');

    // Main Title
    this.doc
      .fontSize(32)
      .fillColor('#2a2a6a')
      .text('Brand Analysis Report', this.margin, 120, {
        align: 'center'
      });

    // Brand Name
    this.doc
      .fontSize(24)
      .fillColor('#6658f4')
      .text(analysisData.brandName || analysisData.domain, this.margin, 180, {
        align: 'center'
      });

    // Info Box
    const boxY = 250;
    this.doc
      .rect(this.margin, boxY, this.contentWidth, 120)
      .stroke('#b0b0d8')
      .fillAndStroke('#f8f9ff', '#b0b0d8');

    // Info content
    this.doc
      .fontSize(14)
      .fillColor('#4a4a6a');

    const infoY = boxY + 25;
    this.addInfoRow('Domain:', analysisData.domain, infoY);
    this.addInfoRow('Analysis Date:', new Date(analysisData.analysisDate).toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }), infoY + 25);
    this.addInfoRow('Report Type:', 'Super User Analysis', infoY + 50);

    // Footer
    this.doc
      .fontSize(10)
      .fillColor('#888')
      .text('Generated by Snowball - AI-Powered Brand Analysis', this.margin, 700, {
        align: 'center'
      });
  }

  addInfoRow(label, value, y) {
    this.doc
      .fontSize(12)
      .fillColor('#4a4a6a');
    
    this.doc.text(label, this.margin + 20, y, { continued: true });
    this.doc.text(` ${value}`, { align: 'left' });
  }

  addExecutiveSummary(analysisData) {
    this.addSectionTitle('Executive Summary');

    // Metrics box
    const boxY = 140;
    this.doc
      .rect(this.margin, boxY, this.contentWidth, 150)
      .fillAndStroke('#f8f9ff', '#b0b0d8');

    // Key metrics
    const metricsY = boxY + 30;
    const col1X = this.margin + 30;
    const col2X = this.margin + (this.contentWidth / 2) + 30;

    this.addMetric('AI Visibility Score', `${Math.round(analysisData.aiVisibilityScore || 0)}%`, col1X, metricsY);
    this.addMetric('Brand Market Share', `${Math.round(analysisData.brandShare || 0)}%`, col2X, metricsY);
    this.addMetric('Total Mentions', (analysisData.totalMentions || 0).toString(), col1X, metricsY + 40);
    this.addMetric('Competitors Found', (analysisData.competitors?.length || 0).toString(), col2X, metricsY + 40);

    // Description
    this.doc
      .fontSize(16)
      .fillColor('#4a4a6a')
      .text('Brand Description', this.margin, 320);

    this.doc
      .fontSize(12)
      .fillColor('#333')
      .text(analysisData.description || 'No description available.', this.margin, 350, {
        width: this.contentWidth,
        lineGap: 5
      });
  }

  addMetric(label, value, x, y) {
    this.doc
      .fontSize(10)
      .fillColor('#666')
      .text(label, x, y);
    
    this.doc
      .fontSize(16)
      .fillColor('#6658f4')
      .text(value, x, y + 15);
  }

  addShareOfVoiceSection(analysisData) {
    this.addSectionTitle('Share of Voice Analysis');

    if (!analysisData.shareOfVoice || Object.keys(analysisData.shareOfVoice).length === 0) {
      this.doc
        .fontSize(12)
        .fillColor('#666')
        .text('No Share of Voice data available.', this.margin, 140);
      return;
    }

    // Table header
    const tableY = 160;
    const rowHeight = 25;
    const col1X = this.margin;
    const col2X = this.margin + 200;
    const col3X = this.margin + 320;
    const col4X = this.margin + 420;

    // Header background
    this.doc
      .rect(col1X, tableY, this.contentWidth, rowHeight)
      .fill('#6658f4');

    // Header text
    this.doc
      .fontSize(12)
      .fillColor('white')
      .text('Brand/Competitor', col1X + 10, tableY + 8)
      .text('Share of Voice', col2X + 10, tableY + 8)
      .text('Mentions', col3X + 10, tableY + 8)
      .text('Rank', col4X + 10, tableY + 8);

    // Sort entries by percentage
    const sortedEntries = Object.entries(analysisData.shareOfVoice).sort((a, b) => b[1] - a[1]);
    
    let currentY = tableY + rowHeight;
    sortedEntries.forEach(([brand, percentage], index) => {
      const mentions = analysisData.mentionCounts[brand] || 0;
      const isEven = index % 2 === 0;
      
      // Row background
      if (isEven) {
        this.doc
          .rect(col1X, currentY, this.contentWidth, rowHeight)
          .fill('#f8f9ff');
      }

      // Row text
      this.doc
        .fontSize(11)
        .fillColor('#333')
        .text(brand.substring(0, 25), col1X + 10, currentY + 8)
        .text(`${percentage.toFixed(1)}%`, col2X + 10, currentY + 8)
        .text(mentions.toString(), col3X + 10, currentY + 8);

      // Rank indicator
      if (index === 0) {
        this.doc
          .fillColor('#ffa500')
          .text('★', col4X + 20, currentY + 8);
      } else {
        this.doc
          .fillColor('#666')
          .text(`#${index + 1}`, col4X + 10, currentY + 8);
      }

      currentY += rowHeight;
    });
  }

  addCompetitorsSection(analysisData) {
    this.addSectionTitle('Competitor Analysis');

    if (!analysisData.competitors || analysisData.competitors.length === 0) {
      this.doc
        .fontSize(12)
        .fillColor('#666')
        .text('No competitors identified in this analysis.', this.margin, 140);
      return;
    }

    this.doc
      .fontSize(14)
      .fillColor('#4a4a6a')
      .text(`Found ${analysisData.competitors.length} competitors:`, this.margin, 140);

    let currentY = 170;
    analysisData.competitors.forEach((competitor, index) => {
      // Competitor box
      this.doc
        .rect(this.margin, currentY, this.contentWidth, 30)
        .fillAndStroke('#f8f9ff', '#b0b0d8');

      // Competitor text
      this.doc
        .fontSize(12)
        .fillColor('#4a4a6a')
        .text(`${index + 1}. ${competitor}`, this.margin + 15, currentY + 10);

      currentY += 35;
      
      // Add page break if needed
      if (currentY > 700 && index < analysisData.competitors.length - 1) {
        this.doc.addPage();
        currentY = 100;
      }
    });
  }

  addCategoriesSection(categories) {
    this.addSectionTitle('Detailed Category Analysis');
    
    this.doc
      .fontSize(12)
      .fillColor('#666')
      .text(`Analysis across ${categories.length} business categories with AI-generated insights:`, 
        this.margin, 140, { width: this.contentWidth });

    // Add competitor mention summary
    this.addCompetitorMentionSummary(categories);

    let currentY = 220;

    categories.forEach((category, index) => {
      // Check if we need a new page
      if (currentY > 650) {
        this.doc.addPage();
        currentY = 100;
      }

      // Category header
      this.doc
        .rect(this.margin, currentY, this.contentWidth, 25)
        .fill('#6658f4');

      this.doc
        .fontSize(14)
        .fillColor('white')
        .text(`Category ${index + 1}: ${category.categoryName}`, this.margin + 10, currentY + 8);

      currentY += 35;

      // Process prompts and responses
      if (category.prompts && category.prompts.length > 0) {
        category.prompts.forEach((prompt, promptIndex) => {
          // Check page space
          if (currentY > 600) {
            this.doc.addPage();
            currentY = 100;
          }

          // Prompt header
          this.doc
            .rect(this.margin, currentY, this.contentWidth, 20)
            .fillAndStroke('#f0f0f0', '#ccc');

          this.doc
            .fontSize(11)
            .fillColor('#4a4a6a')
            .text(`Prompt ${promptIndex + 1}`, this.margin + 10, currentY + 6);

          currentY += 25;

          // Prompt text
          const promptText = prompt.promptText || 'No prompt text available';
          const promptHeight = this.doc.heightOfString(promptText, { width: this.contentWidth - 20 });
          
          this.doc
            .fontSize(10)
            .fillColor('#333')
            .text(promptText, this.margin + 10, currentY, { 
              width: this.contentWidth - 20,
              lineGap: 2
            });

          currentY += promptHeight + 15;

          // AI Response
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            // Check for competitor mentions in this response
            const responseText = prompt.aiResponse.responseText;
            const competitorNames = [
              'salesforce', 'hubspot', 'outreach', 'salesloft', 'groove', 
              'pipedrive', 'zoho', 'apollo', 'linkedin sales navigator', 'zoominfo'
            ];
            
            const mentionedCompetitors = competitorNames.filter(competitor => 
              responseText.toLowerCase().includes(competitor.toLowerCase())
            );

            // Response header with competitor indicator
            const headerColor = mentionedCompetitors.length > 0 ? '#ff6b35' : '#4a90e2';
            const headerBgColor = mentionedCompetitors.length > 0 ? '#fff3f0' : '#e6f3ff';
            
            this.doc
              .rect(this.margin, currentY, this.contentWidth, 20)
              .fillAndStroke(headerBgColor, headerColor);

            const headerText = mentionedCompetitors.length > 0 
              ? `AI Response (Mentions: ${mentionedCompetitors.join(', ')})`
              : 'AI Response';

            this.doc
              .fontSize(11)
              .fillColor(headerColor)
              .text(headerText, this.margin + 10, currentY + 6);

            currentY += 25;

            // Response text
            const responseHeight = this.doc.heightOfString(responseText, { width: this.contentWidth - 20 });
            
            this.doc
              .fontSize(10)
              .fillColor('#333')
              .text(responseText, this.margin + 10, currentY, { 
                width: this.contentWidth - 20,
                lineGap: 2
              });

            currentY += responseHeight + 20;
          } else {
            this.doc
              .fontSize(10)
              .fillColor('#999')
              .text('No AI response available.', this.margin + 10, currentY);
            currentY += 25;
          }
        });
      } else {
        this.doc
          .fontSize(11)
          .fillColor('#666')
          .text('No prompts available for this category.', this.margin + 10, currentY);
        currentY += 30;
      }

      currentY += 20; // Space between categories
    });
  }

  addCompetitorMentionSummary(categories) {
    // Extract all competitor mentions from AI responses
    const competitorMentions = {};
    const competitorPrompts = {};
    
    categories.forEach((category, categoryIndex) => {
      if (category.prompts) {
        category.prompts.forEach((prompt, promptIndex) => {
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            const response = prompt.aiResponse.responseText.toLowerCase();
            
            // Common competitor patterns to look for
            const competitorNames = [
              'salesforce', 'hubspot', 'outreach', 'salesloft', 'groove', 
              'pipedrive', 'zoho', 'apollo', 'linkedin sales navigator', 'zoominfo'
            ];
            
            competitorNames.forEach(competitor => {
              if (response.includes(competitor.toLowerCase())) {
                if (!competitorMentions[competitor]) {
                  competitorMentions[competitor] = 0;
                  competitorPrompts[competitor] = [];
                }
                competitorMentions[competitor]++;
                competitorPrompts[competitor].push({
                  category: category.categoryName,
                  prompt: prompt.promptText.substring(0, 60) + '...',
                  categoryIndex: categoryIndex + 1,
                  promptIndex: promptIndex + 1
                });
              }
            });
          }
        });
      }
    });

    // Display competitor mention summary
    if (Object.keys(competitorMentions).length > 0) {
      this.doc
        .fontSize(14)
        .fillColor('#4a4a6a')
        .text('📊 Competitor Mentions Summary:', this.margin, 165);

      let summaryY = 185;
      Object.entries(competitorMentions).forEach(([competitor, count]) => {
        this.doc
          .fontSize(11)
          .fillColor('#6658f4')
          .text(`• ${competitor}: ${count} mentions`, this.margin + 10, summaryY);
        summaryY += 12;
      });
    }
  }

  addSectionTitle(title) {
    // Section line
    this.doc
      .moveTo(this.margin, 110)
      .lineTo(this.pageWidth - this.margin, 110)
      .stroke('#6658f4');

    // Section title
    this.doc
      .fontSize(20)
      .fillColor('#2a2a6a')
      .text(title, this.margin, 80);
  }
}

module.exports = BrandAnalysisPDFGenerator;