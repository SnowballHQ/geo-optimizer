const PDFDocument = require('pdfkit');

class BrandAnalysisPDFGenerator {
  constructor() {
    this.doc = null;
    this.pageWidth = 612;
    this.pageHeight = 792;
    this.margin = 50;
    this.contentWidth = this.pageWidth - (this.margin * 2);
    
    // Updated color scheme to match website theme
    this.colors = {
      primary: '#7765e3',        // Main brand color
      primaryLight: '#a4abff',   // Lighter primary
      primaryDark: '#5e6ad2',    // Darker primary
      text: '#2d3142',           // Dark text
      textLight: '#4a4a6a',      // Light text
      textMuted: '#6b7280',      // Muted text
      background: '#ffffff',      // White background
      surface: '#f8f9ff',        // Light surface
      border: '#e4e7ff',         // Light border
      accent: '#10b981',         // Success green
      warning: '#f59e0b',        // Warning orange
      error: '#ef4444'           // Error red
    };
  }

  generateBrandAnalysisPDF(analysisData) {
    return new Promise((resolve, reject) => {
      try {
        this.doc = new PDFDocument({ 
          margin: this.margin,
          font: 'Helvetica'
        });
        const buffers = [];

        // Collect the PDF data
        this.doc.on('data', buffers.push.bind(buffers));
        this.doc.on('end', () => {
          const pdfData = Buffer.concat(buffers);
          resolve(pdfData);
        });

        // Generate the PDF content
        this.generateContent(analysisData);

        // Finalize the PDF
        this.doc.end();
      } catch (error) {
        console.error('❌ PDF Generation Error:', error);
        reject(new Error(`PDF generation failed: ${error.message}`));
      }
    });
  }

  generateContent(analysisData) {
    // Title Page
    this.addTitlePage(analysisData);
    this.doc.addPage();

    // Executive Summary
    this.addExecutiveSummary(analysisData);
    this.doc.addPage();

    // Share of Voice Analysis
    this.addShareOfVoiceSection(analysisData);
    this.doc.addPage();

    // Competitors Section
    this.addCompetitorsSection(analysisData);

    // Categories Analysis
    if (analysisData.categories && analysisData.categories.length > 0) {
      this.doc.addPage();
      this.addCategoriesSection(analysisData.categories);
    }
  }

  addTitlePage(analysisData) {
    const centerX = this.pageWidth / 2;

    // Brand header bar with primary color
    this.doc
      .rect(0, 80, this.pageWidth, 6)
      .fill(this.colors.primary);

    // Main Title
    this.doc
      .fontSize(36)
      .fillColor(this.colors.text)
      .text('Brand Analysis Report', this.margin, 120, {
        align: 'center'
      });

    // Brand Name
    this.doc
      .fontSize(28)
      .fillColor(this.colors.primary)
      .text(analysisData.brandName || analysisData.domain, this.margin, 180, {
        align: 'center'
      });

    // Info Box with improved styling
    const boxY = 250;
    this.doc
      .rect(this.margin, boxY, this.contentWidth, 120)
      .stroke(this.colors.border)
      .fillAndStroke(this.colors.surface, this.colors.border);

    // Info content
    this.doc
      .fontSize(14)
      .fillColor(this.colors.textLight);

    const infoY = boxY + 25;
    this.addInfoRow('Domain:', analysisData.domain, infoY);
    this.addInfoRow('Analysis Date:', new Date(analysisData.analysisDate).toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }), infoY + 25);
    this.addInfoRow('Report Type:', 'Super User Analysis', infoY + 50);

    // Footer
    this.doc
      .fontSize(10)
      .fillColor(this.colors.textMuted)
      .text('Generated by Snowball - AI-Powered Brand Analysis', this.margin, 700, {
        align: 'center'
      });
  }

  addInfoRow(label, value, y) {
    this.doc
      .fontSize(12)
      .fillColor(this.colors.textLight);
    
    this.doc.text(label, this.margin + 20, y, { continued: true });
    this.doc.text(` ${value}`, { align: 'left' });
  }

  addExecutiveSummary(analysisData) {
    this.addSectionTitle('Executive Summary');

    // Metrics box with improved design
    const boxY = 140;
    this.doc
      .rect(this.margin, boxY, this.contentWidth, 150)
      .fillAndStroke(this.colors.surface, this.colors.border);

    // Key metrics
    const metricsY = boxY + 30;
    const col1X = this.margin + 30;
    const col2X = this.margin + (this.contentWidth / 2) + 30;

    this.addMetric('AI Visibility Score', `${Math.round(analysisData.aiVisibilityScore || 0)}%`, col1X, metricsY);
    this.addMetric('Brand Market Share', `${Math.round(analysisData.brandShare || 0)}%`, col2X, metricsY);
    this.addMetric('Total Mentions', (analysisData.totalMentions || 0).toString(), col1X, metricsY + 40);
    this.addMetric('Competitors Found', (analysisData.competitors?.length || 0).toString(), col2X, metricsY + 40);

    // Description
    this.doc
      .fontSize(16)
      .fillColor(this.colors.text)
      .text('Brand Description', this.margin, 320);

    this.doc
      .fontSize(12)
      .fillColor(this.colors.textLight)
      .text(analysisData.description || 'No description available.', this.margin, 350, {
        width: this.contentWidth,
        lineGap: 5
      });
  }

  addMetric(label, value, x, y) {
    this.doc
      .fontSize(10)
      .fillColor(this.colors.textMuted)
      .text(label, x, y);
    
    this.doc
      .fontSize(18)
      .fillColor(this.colors.primary)
      .text(value, x, y + 15);
  }

  addShareOfVoiceSection(analysisData) {
    this.addSectionTitle('Share of Voice Analysis');

    if (!analysisData.shareOfVoice || Object.keys(analysisData.shareOfVoice).length === 0) {
      this.doc
        .fontSize(12)
        .fillColor(this.colors.textMuted)
        .text('No Share of Voice data available.', this.margin, 140);
      return;
    }

    // Table header with primary color
    const tableY = 160;
    const rowHeight = 25;
    const col1X = this.margin;
    const col2X = this.margin + 200;
    const col3X = this.margin + 320;
    const col4X = this.margin + 420;

    // Header background
    this.doc
      .rect(col1X, tableY, this.contentWidth, rowHeight)
      .fill(this.colors.primary);

    // Header text
    this.doc
      .fontSize(12)
      .fillColor('white')
      .text('Brand/Competitor', col1X + 10, tableY + 8)
      .text('Share of Voice', col2X + 10, tableY + 8)
      .text('Mentions', col3X + 10, tableY + 8)
      .text('Rank', col4X + 10, tableY + 8);

    // Sort entries by percentage
    const sortedEntries = Object.entries(analysisData.shareOfVoice).sort((a, b) => b[1] - a[1]);
    
    let currentY = tableY + rowHeight;
    sortedEntries.forEach(([brand, percentage], index) => {
      const mentions = analysisData.mentionCounts[brand] || 0;
      const isEven = index % 2 === 0;
      
      // Row background
      if (isEven) {
        this.doc
          .rect(col1X, currentY, this.contentWidth, rowHeight)
          .fill(this.colors.surface);
      }

      // Row text
      this.doc
        .fontSize(11)
        .fillColor(this.colors.text)
        .text(brand.substring(0, 25), col1X + 10, currentY + 8)
        .text(`${percentage.toFixed(1)}%`, col2X + 10, currentY + 8)
        .text(mentions.toString(), col3X + 10, currentY + 8);

      // Rank indicator
      if (index === 0) {
        this.doc
          .fillColor(this.colors.warning)
          .text('★', col4X + 20, currentY + 8);
      } else {
        this.doc
          .fillColor(this.colors.textMuted)
          .text(`#${index + 1}`, col4X + 10, currentY + 8);
      }

      currentY += rowHeight;
    });
  }

  addCompetitorsSection(analysisData) {
    this.addSectionTitle('Competitor Analysis');

    if (!analysisData.competitors || analysisData.competitors.length === 0) {
      this.doc
        .fontSize(12)
        .fillColor(this.colors.textMuted)
        .text('No competitors identified in this analysis.', this.margin, 140);
      return;
    }

    this.doc
      .fontSize(14)
      .fillColor(this.colors.text)
      .text(`Found ${analysisData.competitors.length} competitors:`, this.margin, 140);

    let currentY = 170;
    analysisData.competitors.forEach((competitor, index) => {
      // Competitor box with improved styling
      this.doc
        .rect(this.margin, currentY, this.contentWidth, 30)
        .fillAndStroke(this.colors.surface, this.colors.border);

      // Competitor text
      this.doc
        .fontSize(12)
        .fillColor(this.colors.text)
        .text(`${index + 1}. ${competitor}`, this.margin + 15, currentY + 10);

      currentY += 35;
      
      // Add page break if needed
      if (currentY > 700 && index < analysisData.competitors.length - 1) {
        this.doc.addPage();
        currentY = 100;
      }
    });
  }

  addCategoriesSection(categories) {
    this.addSectionTitle('Detailed Category Analysis');
    
    this.doc
      .fontSize(12)
      .fillColor(this.colors.textMuted)
      .text(`Analysis across ${categories.length} business categories with AI-generated insights:`, 
        this.margin, 140, { width: this.contentWidth });

    // Add competitor mention summary with improved design
    const competitorMentionsY = this.addCompetitorMentionSummary(categories);

    let currentY = competitorMentionsY + 10; // Reduced spacing

    categories.forEach((category, index) => {
      // Category header with primary color
      this.doc
        .rect(this.margin, currentY, this.contentWidth, 25)
        .fill(this.colors.primary);

      this.doc
        .fontSize(14)
        .fillColor('white')
        .text(`Category ${index + 1}: ${category.categoryName}`, this.margin + 10, currentY + 8);

      currentY += 30; // Reduced spacing

      // Process prompts and responses
      if (category.prompts && category.prompts.length > 0) {
        category.prompts.forEach((prompt, promptIndex) => {
          // Calculate total content height needed for this prompt+response
          const promptText = prompt.promptText || 'No prompt text available';
          const promptHeight = this.doc.heightOfString(promptText, { width: this.contentWidth - 20 });
          
          let responseHeight = 0;
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            responseHeight = this.doc.heightOfString(prompt.aiResponse.responseText, { width: this.contentWidth - 20 });
          }
          
          const totalNeededHeight = 20 + promptHeight + 35 + responseHeight + 30; // Headers + content + spacing
          
          // Check if we need a new page - only if content won't fit
          if (currentY + totalNeededHeight > 730) {
            this.doc.addPage();
            currentY = 80;
          }

          // Prompt header with improved styling
          this.doc
            .rect(this.margin, currentY, this.contentWidth, 18)
            .fillAndStroke(this.colors.surface, this.colors.border);

          this.doc
            .fontSize(11)
            .fillColor(this.colors.text)
            .text(`Prompt ${promptIndex + 1}`, this.margin + 10, currentY + 5);

          currentY += 22;

          // Prompt text
          this.doc
            .fontSize(10)
            .fillColor(this.colors.textLight)
            .text(promptText, this.margin + 10, currentY, { 
              width: this.contentWidth - 20,
              lineGap: 1
            });

          currentY += promptHeight + 10;

          // AI Response
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            // Response header
            this.doc
              .rect(this.margin, currentY, this.contentWidth, 18)
              .fillAndStroke(this.colors.surface, this.colors.border);

            this.doc
              .fontSize(11)
              .fillColor(this.colors.text)
              .text('AI Response', this.margin + 10, currentY + 5);

            currentY += 22;

            // Response text
            const responseText = prompt.aiResponse.responseText;
            
            this.doc
              .fontSize(10)
              .fillColor(this.colors.text)
              .text(responseText, this.margin + 10, currentY, { 
                width: this.contentWidth - 20,
                lineGap: 1
              });

            currentY += responseHeight + 15;
          } else {
            this.doc
              .fontSize(10)
              .fillColor(this.colors.textMuted)
              .text('No AI response available.', this.margin + 10, currentY);
            currentY += 20;
          }
        });
      } else {
        this.doc
          .fontSize(11)
          .fillColor(this.colors.textMuted)
          .text('No prompts available for this category.', this.margin + 10, currentY);
        currentY += 25;
      }

      currentY += 10; // Reduced space between categories
    });
  }

  addCompetitorMentionSummary(categories) {
    // Extract all competitor mentions from AI responses
    const competitorMentions = {};
    const competitorPrompts = {};
    
    categories.forEach((category, categoryIndex) => {
      if (category.prompts) {
        category.prompts.forEach((prompt, promptIndex) => {
          if (prompt.aiResponse && prompt.aiResponse.responseText) {
            const response = prompt.aiResponse.responseText.toLowerCase();
            
            // Enhanced competitor patterns to look for
            const competitorNames = [
              'salesforce', 'hubspot', 'outreach', 'salesloft', 'groove', 
              'pipedrive', 'zoho', 'apollo', 'linkedin sales navigator', 'zoominfo',
              'mailchimp', 'constant contact', 'convertkit', 'activecampaign',
              'klaviyo', 'drip', 'getresponse', 'aweber', 'infusionsoft',
              'keap', 'pipedrive', 'freshsales', 'zendesk', 'intercom',
              'drift', 'calendly', 'acuity', 'calendly', 'typeform',
              'survey monkey', 'google forms', 'notion', 'airtable', 'trello',
              'asana', 'monday.com', 'clickup', 'wrike', 'teamgantt'
            ];
            
            competitorNames.forEach(competitor => {
              if (response.includes(competitor.toLowerCase())) {
                if (!competitorMentions[competitor]) {
                  competitorMentions[competitor] = 0;
                  competitorPrompts[competitor] = [];
                }
                competitorMentions[competitor]++;
                competitorPrompts[competitor].push({
                  category: category.categoryName,
                  prompt: prompt.promptText,
                  categoryIndex: categoryIndex + 1,
                  promptIndex: promptIndex + 1
                });
              }
            });
          }
        });
      }
    });

    // Display competitor mentions summary as a table
    if (Object.keys(competitorMentions).length > 0) {
      this.doc
        .fontSize(16)
        .fillColor(this.colors.text)
        .text('Competitor Mentions Summary', this.margin, 165);

      let summaryY = 190;
      
      // Create a compact table format
      Object.entries(competitorMentions).forEach(([competitor, count]) => {
        // Check if we need space for this competitor section
        if (summaryY > 650) {
          this.doc.addPage();
          summaryY = 80;
        }

        // Competitor header box
        this.doc
          .rect(this.margin, summaryY, this.contentWidth, 20)
          .fillAndStroke(this.colors.surface, this.colors.primary);

        this.doc
          .fontSize(12)
          .fillColor(this.colors.primary)
          .text(`${competitor.toUpperCase()} (${count} mentions)`, this.margin + 10, summaryY + 6);
        
        summaryY += 25;
        
        // List prompts in compact format - just show category and prompt number
        competitorPrompts[competitor].forEach((promptInfo, index) => {
          const shortText = `Category ${promptInfo.categoryIndex}, Prompt ${promptInfo.promptIndex}: "${promptInfo.prompt.substring(0, 80)}..."`;
          
          this.doc
            .fontSize(9)
            .fillColor(this.colors.textLight)
            .text(`• ${shortText}`, this.margin + 15, summaryY, {
              width: this.contentWidth - 30,
              lineGap: 1
            });
          
          summaryY += 14; // Tight spacing for compact layout
        });
        
        summaryY += 10; // Small space between competitors
      });
      
      return summaryY + 15; // Return the Y position for continuing content
    }
    
    return 190; // Return default Y position if no competitors
  }

  addSectionTitle(title) {
    // Section line with primary color
    this.doc
      .moveTo(this.margin, 110)
      .lineTo(this.pageWidth - this.margin, 110)
      .stroke(this.colors.primary);

    // Section title
    this.doc
      .fontSize(20)
      .fillColor(this.colors.text)
      .text(title, this.margin, 80);
  }
}

module.exports = BrandAnalysisPDFGenerator;